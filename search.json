[{"title":"在 Hexo 中插入数学公式","date":"2023-04-05T15:45:09.000Z","url":"/2023/hexo-formulas/","tags":["Hexo"],"content":"在有些时候，我需要在文章中插入数学公式（例如变量等），这时候会想到使用 $\\LaTeX$ 公式。但是 Hexo 和我当前的主题默认没有支持 $\\LaTeX$ 公式渲染，因此本文通过增加 Hexo 主题脚本片段的方式实现 $\\LaTeX$ 语法高亮。 主题使用 Mathjax你可以从主题文件的 README.md 确认你的 Hexo 主题是否已经引入了 Mathjax，如果已经引入，那你只要按照说明来开启 Mathjax 支持即可。如果你的主题并不支持 Mathjax，那你可以按照以下步骤使你的 Hexo 支持 Mathjax。 你需要在 themes/YourThemeName/layout/ 下新建文件 mathjax.ejs 文件。 你需要在 themes/YourThemeName/_config.yml 末尾追加： 为了保障国内网络环境的访问，将原文的CDN修改为字节跳动静态资源公共库。 修改 themes/YourThemeName/layout/post.ejs 文件，在中间添加： 至此，大功告成～你最后只需要重新生成一下文章就可以看到你的文章现在已经支持 $\\LaTeX$ 公式了。 测试测试一下你的文章是否已经支持 LaTex 公式： 如果你的文章已经支持那么上面的 LaTex 语法将会有如下显示： $$ J_\\alpha(x) &#x3D; \\sum_{m&#x3D;0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} $$ 参考文章"},{"title":"机试笔记","date":"2023-03-25T15:20:20.000Z","url":"/2023/Online-Judge/","tags":["算法"],"content":"我习惯的格式化风格： 语言基础数组字符数组的输入输出 string.h 头文件 strlen(s): 得到字符数组长度（不包含最后的\\0）。 strcmp(s1, s2): 以字典序比较数组大小。$s1 &lt; s2$ 返回负数，$s1 &gt; s2$ 返回正数，相等返回 $0$。 strcpy(s1, s2): 把 $s2$ 复制给 $s1$，包括结束符\\0。 strcat(s1, s2): 把 $s2$ 接到 $s1$ 后面。 sscanf 与 sprintfsscanf 将字符数组的内容按一定格式写到变量或其他字符数组中。 输出：n = 2048, db = 3.14, str2 = hello。 sprintf 将变量或字符数组以一定格式写到一个字符数组中。 输出：str = 12:3.14, good。 结构体结构体的定义与访问定义一个student类型。 访问 $stu$ 中元素：stu.id stu.name stu.next。 访问 $p$ 中元素：p-&gt;id p-&gt;name p-&gt;next。 结构体的初始化 输出结果：Michael Jackson 19580829 M。 入门模拟日期处理闰年判断 日期差值 进制转换反序数 转换为十进制数 从十进制数转换 算法初步排序快速排序 求第 $k$ 小的数（令最小为第 $0$ 小），将快速排序稍作修改。 此时R[k]即为所求。由于每次处理的区间长度都会减半，所以是线性复杂度。 sort() 函数#include &lt;algorithm&gt; 使用方式：sort(first, last, [cmp]) 给地址为 $[first,last)$ 内的元素排序。如果不写比较函数cmp，默认进行递增排序。 比较函数的例子： 贪心简单贪心金币与背包问题：在背包中装入价值量最高的金币。 区间贪心区间不相交问题：给出数个开区间 $(x,y)$，从中尽可能选择多的区间，使它们两两不相交。总是先选择左端点最大的区间，相同时先选择右端点最小的区间（反之也可以）。 区间选点问题：给出数个闭区间 $[x,y]$，最少需要确定几个点，才能使每个闭区间都存在至少一个点。本质上就是求两两不相交的区间数，只需把以上代码中的I[i].right &lt;= lastLeft改成I[i].right &lt; lastLeft即可。 二分二分查找递归版 迭代版 固定模板：寻找有序序列中第一个满足某条件的元素的位置 如果要求最后一个满足条件的元素的位置，可以先求第一个满足!条件的元素位置，然后减1即可。 可以用lower_bound()和upper_bound()实现。 函数估计二分法估计函数参数 数学问题最大公约数与最小公倍数 分数分数的表示与化简最简洁的写法是写成假分数的形式，分子分母都保留原数。 分数的化简分为三步： 如果分母 $down$ 为负数，则令分子 $up$ 与分母 $down$ 都变为相反数。 如果分子 $up$ 为 $0$，则令分母 $down$ 为 $1$。 约分：求分子绝对值与分母绝对值的最大公约数，然后令分子分母同时除以该数。 分数的四则运算 分数的输出 输出分数前，先进行化简。 如果分母 $down$ 为 $1$，说明是整数，则直接输出分子。 如果分子 $up$ 的绝对值大于分母 $down$，说明是假分数，则按带分数的形式输出。 真分数直接输出即可。 分数的乘除法可以使分子或分母超出int表示范围，一般情况下，使用long long存储。 素数素数判断 如果 $n$ 接近上界，会导致 $i*i$ 溢出，则采用开根号的写法i &lt;= (int)sqrt(n)。 素数表获取 大整数整数的高位存储在数组的高位，整数的低位存储在数组的低位。因此读入之后需要在另存为d[]数组的时候反转。 定义大整数结构体 输入大整数读入字符串，另存为bign。 比较两数大小 大整数运算加法 减法 乘法 除法 STLvector变长数组 #include &lt;vector&gt; 元素访问： 通过下标访问（vi[index]）。 通过迭代器访问。 常用STL容器中，只有vector和string支持vi.begin()+3这种迭代器加上整数的写法。 常用实例： vi.push_back(x): 在末尾追加元素 $x$。 vi.pop_back(): 删除尾元素。 vi.size(): 返回变长数组长度。 vi.clear(): 清空所有元素。 vi.insert(it, x): 在迭代器it处插入元素 $x$。 vi.erase(it): 删除单个元素，it 为需要删除元素的迭代器；vi.erase(first, last): 删除迭代器 $[first,last)$ 内的元素。 set内部自动升序且不含重复元素的容器。 include &lt;set&gt; 常用实例： st.insert(x): 插入元素 $x$。 st.find(value): 返回对应数值为 $value$ 的迭代器，找不到时返回st.end()。 st.erase(it): it为所需要删除元素的迭代器；st.erase(value): $value$ 为所需要删除元素的值；st.erase(first, last): 删除迭代器 $[first,last)$ 内的元素。 st.size(): 获得元素个数。 st.clear(): 清空所有元素。 如果要逆序（降序）输出： set中是数据是唯一的。如果要处理不唯一的情况，用multiset。如果要只去重不排序，使用unordered_set。 string#include &lt;string&gt; 输入输出： cin与getline混用需谨慎。cin &gt;&gt;不会读入最后的换行符\\n，而getline是以\\n为结束标记的。如果必须混用，在cin &gt;&gt;这句后面加一行cin.ignore()。 常用实例： s += str或s.append(str): 在字符串 s 后拼接字符串 str。 s &lt; str: 以字典序比较两个字符串。 s.length()或s.size(): 字符串长度。 s.substr(pos, len): 范围从 pos 号位开始、长度为 len 的子串。 s.insert(pos, str): 在 pos 号位置插入字符串 str。 s.find(str, [pos]): （从 pos 号位开始）匹配 str，返回其在 s 中第一次出现的位置；如果 str 不是子串，则返回string::npos（unsigned_int 类型的最大值，强制转换为 int 类型后为-1，比较时可以令为-1）。 s.erase(it): 删除单个元素，it 为需要删除元素的迭代器；s.erase(first, last): 删除迭代器 $[first,last)$ 内的元素。 s.clear(): 清空字符串。 map#include &lt;map&gt; 定义：需要确定键 $key$ 与值 $value$ 两种类型。 map&lt;typename1, typename2&gt; mp; 如果以字符串为键，必须使用string而不能使用char数组。 访问： 输出：a:30 b:20 c:10。 map会以键从小到大的顺序自动排序。不要排序，使用unordered_map。 常用实例： mp.find(key): 返回键为 $key$ 的迭代器，找不到时返回mp.end()。 mp.erase(it): it为所需要删除元素的迭代器；mp.erase(key): $key$ 为所需要删除元素的键；mp.erase(first, last): 删除迭代器 $[first,last)$ 内的元素。 mp.size(): 返回映射的对数。 mp.clear(): 清空所有元素。 stack#include &lt;stack&gt; 常用实例： st.push(x): 将 $x$ 入栈。 st.top(): 获得栈顶元素。 st.pop(): 弹出栈顶元素。 st.empty(): 检测栈是否为空。 st.size(): 返回栈内元素个数。 栈的清空：可以用一个循环反复弹出元素直至清空。 事实上更常用的方法是重新定义一个栈来变相实现栈的清空，不需很多时间。 queue#include &lt;queue&gt; 常用实例： q.push(x): 将 $x$ 入队。 q.front(): 获得队首元素。 q.back(): 获得队尾元素元素。 q.pop(): 令队首元素出队。 q.empty(): 检测队是否为空。 q.size(): 返回队内元素个数。 队列的清空：与栈类似。 algorithm 下的常用函数max(x, y)与min(x, y)分别返回 $x$ 与 $y$ 中的最大值和最小值，参数必须是两个，可以是浮点数。如果要比较三个数，可以使用max(x, max(y, z))的写法。 lower_bound(first, last, val)寻找数组或容器的 $[first,last)$ 范围内第一个值大于等于 $val$ 的元素的位置；upper_bound(first, last, val)寻找数组或容器的 $[first,last)$ 范围内第一个值大于 $val$ 的元素的位置。如果是数组，返回指针；如果是容器，返回迭代器。如果想获得元素的下标，另返回值减去数组首地址即可。 栈与队列中缀表达式转后缀表达式 后缀表达式求值 树二叉树的存储结构与基本操作 二叉树的遍历先序遍历 层序遍历 如果要求计算结点所处的层次，结点定义中增加一个int layer。 返回某结点的层级 根据先序遍历序列和中序遍历序列重建二叉树 搜索DFS有 $n$ 件物品，每件物品重量 $w[i]$，价值 $c[i]$。取出若干件物品放入容量为 $V$ 的背包中，让背包内的物品总价值最大，求最大价值。 上述代码中，总是把所有物品全部确定之后才去更新最大价值。可以把对 $sumW$ 的判断加入岔路口中，只有当 $sumW&lt;V$ 时才进入“选择当前物品”的岔道，即剪枝。 常见的DFS解决方法：给定一个序列，枚举这个序列的所有自序列（可以不连续）。 给定 $N$ 个整数（可能为负），从中选择 $K$ 个数，使得它们的和恰好等于给定的整数 $X$；如果有多个方案，从中选择元素平方和最大的方案。 首先确定一个数组 $temp$ 来存放当前已经选择的数。当试图选择a[index]时，就把它加进去；当这条分支结束时，再把它从 $temp$ 中去除，使它不影响“不选择a[index]”这条分支。 如果允许重复选择，则当选择了a[index]时，不应该直接进入a[index+1]的处理，而是应当继续选择a[index]，直到不能再选择为止，再通过“不选 $index$ 号数”的分支进入 $index+1$ 号数的处理。只需把“选 $index$ 号数”的分支改成：DFS(index, nowK + 1, sum + a[index], sumSqu + a[index]);。 BFS模板： 例子： 访问位置 $(x,y)$ 所在的块，将块中所有“$1$”的inq都设置为true。 求起点 $S$ 到终点 $T$ 的最少步数。 "},{"title":"数据结构","date":"2023-02-09T16:54:50.000Z","url":"/2023/Data-Structure/","tags":["算法"],"content":"我的数据结构笔记。 线性表线性表的结构体定义顺序表结构体定义 实际中用得较多的非结构体方法（更简洁）： 定义了一个长度为n、表内元素为整数的顺序表。 单链表结点定义 双链表结点定义 构造链表结点时定义一个指针来存储这片空间的地址（即指针指向节点），并常用这个指针的名称来作为结点的名称，例如： LNode *A = (LNode *)malloc(sizeof(LNode)); 顺序表的操作按元素值查找在顺序表L中查找第一个值等于e的元素，并返回下标。 插入数据元素在顺序表L的p (0≤p≤length)位置插入新的元素e。p输入不正确返回0，插入操作成功返回1。 删除数据元素删除顺序表下标为p (0≤p≤length-1)的元素，成功返回1，否则返回0，并将被删除元素的值赋给e。 单链表的操作建立单链表假设有n个元素已经存储在数组a中，用尾插法建立链表C。 用头插法建立链表C。 插入与删除结点假设p指向一个结点，要将s所指结点插入p所指结点之后。 删除第i个结点，需找到第i-1个结点p（注意要释放内存空间）。 归并A和B是两个单链表（带头结点），元素递增有序，将A和B归并成一个按元素递增的链表C，C由A和B的结点组成。 从A、B中挑出最小的元素插入C的尾部，C一定是递增有序的。如果A、B其中一个已经全部插入C中，再将另一个链接到C的尾部即可。 将A和B归并成一个按元素递减的链表C。 改成头插法即可解决。不需要r追踪C的终端结点，而是用s来接收新的结点，插入C的前端。 查找查找链表C中是否存在一个值为x的结点，若存在则删除该结点并返回1，否则返回0。 定义结点指针变量p，沿着链表一直走到表尾，每遇到一个新结点就检测其值是否为x，是则证明找到，不是则继续检测下一个结点。 双链表的操作建立双链表使用尾插法 查找结点在双链表中查找第一个值为x的结点，若找到则返回结点指针，否则返回NULL。 如果找到，则p中内容是结点地址（循环因break结束）；如果没找到，则p中的内容为NULL（循环因p等于NULL而结束）。 插入结点在双链表中p所指的结点之后插入一个结点s。 先将要插入结点的两边链接好，就可以避免断链后找不到结点的情况。 删除结点删除双链表中p结点的后继结点。 循环链表循环链表的各种操作均与非循环链表类似。需要注意的是，如果p指针沿着循环链表行走，则判断p走到表尾结点的条件是p-&gt;next==head。 逆置问题将线性表的元素逆置，可设置两个整形变量i和j，i指向第一个元素，j指向最后一个元素，边交换i和j所指元素，边让i和j相向而行，直到相遇。假设元素存在于数组a[]中，left和right是数组两端元素的下标。 例题 将一个长度为n的数组的前端 k(k&lt;n) 个元素逆序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。 将一个长度为n的数组的前端 k(k&lt;n) 个元素保持原序移动到数组后端，要求原数组中数据不丢失，其余元素的位置无关紧要。 将数组中的元素 (X0, X1, …, Xn-1)，经过移动后变为 (Xp, Xp+1, …, Xn-1, X0, X1, …, Xp-1)，即循环左移 p(0&lt;p&lt;n) 个位置。 分析 逆置整个数组，即可满足前端k个元素逆序后放到数组后端。 将前端k个元素逆置，然后将整个数组逆置，即可满足前端k个元素原序放到数组后端。 将0到p-1位置的元素逆置，再将p到n-1位置的元素逆置，然后将整个数组逆置。 栈和队列顺序栈的操作结构体定义 初始化栈只需将栈顶指针置为-1即可。 判断栈空栈st为空时返回1，否则返回0。 进栈 出栈 常用写法栈常常作为一个工具来解决其他问题，因此一般情况下，栈的定义和操作可以写得很简单，不必调用以上函数。 定义一个栈并初始化 元素x进栈 元素x出栈 2与3需注意的是，当前栈是否为满，满时不进；是否为空，空时不出。根据实际需要决定写还是不写，不必像标准操作那样每次都判断。 链栈的操作结点定义 初始化 判断栈空当栈空时返回1，否则返回0。 进栈栈不空时可以执行，返回1，否则返回0。 出栈 和顺序栈一样，不必严格写出操作函数，只需摘取必要的语句结合在代码中即可。 栈的应用顺序栈的应用【例3-1】 C语言算数表达式中的括号只有小括号。编写算法，判断一个表达式中的括号是否正确配对，表达式已经存入字符数组exp[]中，表达式的字符个数为n。 一个问题中如果出现诸如这种情况，即在解决问题的过程中出现了一个子问题，但凭现有条件不能解决它，需要记下，等待以后出现可以解决它的条件后再返回来解决。这种问题需要用栈来解决，这是栈的FILO特性所延申出来的一种特性。 【例3-2】 编写一个函数，求后缀式的数值，其中后缀式存于一个字符数组exp中，其中最后一个字符是\\0作为结束符，并且假设后缀式中的数字都只有一位。本题的除法运算皆为整数运算，如2&#x2F;3结果为0，3&#x2F;2结果为1。 (a+b+c×d)/e是一个中缀式，转化为前缀式为/++ab×cde，转化为后缀式为abcd×++e/。 后缀式的求值可以用栈解决。对于一个后缀式，当从左往右扫描到一个数值时，具体怎么运算还不知道，需要扫描到后面的运算符才知道，因此必须先存起来。 执行过程：当遇到数值时入栈，当遇到运算符时连续两次出栈，将两个出栈元素结合运算符进行运算，将结果作为新遇到的数值入栈。如此往复，直到扫描到终止符\\0。此时栈底元素即为表达式的值。 假设有一个字符&#39;5&#39;，定义一个整形变量a=&#39;5&#39;，此时a里保存了5的ASCII码，而不是数字5。要将5这个整数保存于a中，需执行a=&#39;5&#39;-&#39;0&#39;。同理，把一个整形数字a装华为对应的字符型数字存储在字符变量b中，需执行b=a+&#39;0&#39;。但是这种转化只适用于0~9这10个数字。 链栈的应用【例3-3】 用不带头结点的单链表存储链栈，设计初始化栈、判断栈是否为空、进栈和出栈等算法。 不带头结点的单链表lst为空的条件是lst==NULL，进栈和出栈操作都是在表头进行的。 顺序队结构体定义 以下算法在元素入队时，先移动指针，后存入元素；元素出队时，也是先移动指针，后取出元素。选择题根据实际情况来确定先移动指针还是先存取元素。 初始化队列 判断队空 进队 出队 以上函数在书写程序时并不实用，提出其中有用的操作即可。 链队结构体定义 队节点类型 链队类型 初始化队列 判断队空 入队 出队 不需要记忆，读程序并理解操作意义即可。尽量采用顺序队解决问题，避免采用链队，除非明确规定。 串结构体定义可以用以下语句定义一个名为str的串。 一般不采取这种方式，原因是仅仅以&#39;\\0&#39;作为结束标记，在求串长时需要扫描整个串，时间复杂度为O(n)；不如额外定义一个变量存储长度，求串长变成时间复杂度为O(1)的操作。 定长顺序存储 变长分配存储 使用这种存储方式时，需要用函数malloc()来分配一个长度为length、类型为char的连续存储空间。变长分配存储方法有顺序存储结构的特点，操作中串长可根据需要来设定，更加灵活。 基本操作赋值因为串是一个数组，赋值操作不能用=来实现，必须对数组中的每个元素进行逐一赋值。 函数strassign()使用时格式如下： 将&quot;cur input&quot;赋到str串中。执行后，str.ch的值为”cur input”，str.length的值为9。 取串长度使用变长分配存储的情况下，直接使用str.length语句即可。 在没有给出串长度信息的情况下，可以借鉴函数strassign()中的求输入串的长度部分的代码实现。 串比较设两串A和B中的待比较字符分别为a和b，如果a的ASCII码大于（小于）b的ASCII码，则返回A大于（小于）B的标记；如果a等于b，则继续比较下一对字符。经过上述步骤没有比较出A和B大小的情况下，先结束的串为较小串，两串同时结束则返回相等标记。 串连接将两个串首尾相接，合并成一个字符串。 求子串求str串中从pos位置开始，长度为len的子串，子串由substr返回给用户。 串清空 模式匹配对一个某子串的定位操作称为串的模式匹配，其中待定位的子串称为模式串。 串中字符存储在1~length的位置上，注意区分前面的0~length-1的存储位置。 简单模式匹配算法 KMP算法令简单模式匹配算法中的主串位置i不需要回溯。 定义一个next[j]数组，表示模式串中第j个字符发生不匹配时，应从next[j]处的字符开始重新与主串的不匹配处进行比较。 特殊情况： 模式串中的第一个字符与主串i位置不匹配，从主串的下一字符和模式串的第一个字符继续比较，即从s[i+1]与p[1]开始比较，此时next[1]=0。 前后缀不存在重合部分时，从主串中发生不匹配的字符与模式串的第一个字符继续比较，即从s[i]与p[1]开始比较，此时next[j]=1。 求next数组的算法： 当substr[i-1]==substr[j-1]但substr[i]!=substr[j]时，表示前缀（模式串）中的第j个字符发生不匹配，应从next[j]处的字符开始重新与后缀（主串）比较，即把j的值回溯到next[j]。 得到next数组后，将简单模式匹配算法稍作修改得到KMP算法： KMP算法的改进求nextval的一般步骤： 当j等于1时，next[j]赋值为0。 当p[j]不等于p[k](k = next[j])，nextva[j]赋值为next[j]。 当p[j]等于p[k](k = next[j])，nextva[j]赋值为nextval[next[j]]。 树与二叉树 非空二叉树上叶子结点数等于双分支结点数加1。 总分支数&#x3D;总结点数-1（对任何树都适用） n0&#x3D;1+n2+2n3+…+(m-1)nm 二叉树的存储结构顺序存储 结点 A B C D E 数组下标 0 1 2 3 4 5 用一个数组BTree[]来存储一棵二叉树，最适合完全二叉树。例如，得到A的左孩子结点只需访问BTree[1*2]即可。类似地，如果知道了一个结点i，如果2i不大于n，则i的左孩子结点就存在BTree[2*i]内。 链式存储 二叉树的遍历算法先序遍历递归 非递归 中序遍历递归 非递归 后序遍历递归 非递归 逆后续遍历序列是先序遍历序列过程中交换左右子树遍历顺序得到的结果。需要两个栈，stack1用来辅助做逆后序遍历（交换先序遍历的左右子树遍历顺序），并将遍历结果序列压入stack2，然后将stack2的元素全部出栈，所得即为后续遍历序列。 层次遍历 线索二叉树结构体定义 中序线索二叉树通过中序遍历对二叉树线索化的递归算法： 每当访问一个结点时，如果其左指针为空，就把该指针指向其前驱结点；如果前驱结点的右指针为空，就把该指针指向当前访问结点。 通过中序遍历建立中序线索二叉树的主程序如下： 遍历中序线索二叉树 树和森林与二叉树的转换树与二叉树的相互转换手工转换。 左指针（child）指向孩子，右指针指向兄弟（sibling）。 森林与二叉树的相互转换手工转换。 根结点的右孩子指针指向森林中的下一棵树。 树和森林的遍历只有先序遍历（先根再子树）和后序遍历（先子树再根）。 树或森林转换为二叉树后，先序遍历对应二叉树的先序遍历，后序遍历对应二叉树的中序遍历。 赫夫曼树和赫夫曼编码带权路径长度：从该结点到根之间的路径长度乘以结点的权值。 树的带权路径长度（WPL）是树中所有叶子结点的带权路径长度之和。 赫夫曼树的特点： 权值越大的结点离根结点越近。 没有度为1的结点。又叫做正则（严格）二叉树。 带权路径长度最短。 构造赫夫曼树手工构造。 注意：每次都选出根结点最小的两棵树构造新的二叉树，其中不一定包括上一步构造的二叉树。 赫夫曼编码手工编码，对赫夫曼树的每个结点的左右分支进行编号，左0右1。 赫夫曼编码产生最短前缀码： 前缀码：根通往任一叶子结点的路径都不是通往其余叶子结点路径的子路径，因此任一字符的编码串都不是另一字符编码串的前缀。 最短：每个字符的权值是其出现次数，出现次数越多的字符编码长度越短，因此整个字符串编码后的前缀码长度最短。 图邻接矩阵 如果明确说明采用邻接矩阵表示，并且要求写出邻接矩阵定义，则上述代码全写。 如果没有要求写出邻接矩阵定义，只是说图采用邻接矩阵表示，则不许写出以上代码。但需记住，因为解题中要引用结构体的各成员。 函数f()的参数是一个表示图的结构体变量G。例如，若要取图的顶点数赋值给a，就可以写成a=G.n；若要检测编号为i的顶点和编号为j的顶点是否邻接，则看G.edges[i][j]是否等于1。 邻接表 图的遍历算法深度优先搜索遍历DFS算法执行过程：任取一个顶点，访问之，然后检查这个顶点的所有邻接顶点，递归访问其中未被访问过的顶点。 时间复杂度为O(n+e)。 广度优先搜索遍历算法执行过程： 任取图中一个顶点访问，入队，并将这个顶点标记为已访问。 当队列不空时循环执行：出队，依次检查出队顶点的所有邻接顶点，访问没有被访问过的邻接顶点并将其入队。 当队列为空时跳出循环，广度优先搜索完成。 时间复杂度为O(n+e)。 最小（代价）生成树普里姆算法从图中选取一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到一棵有2个顶点的树。然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入当前树中，得到一棵有3个顶点的树。以此类推，直到图中所有顶点都并入树中为止。 普里姆算法的时间复杂度为O(n²)。 克鲁斯卡尔算法每次找出侯选边中权值最小的边，就将该边并入生成树中。重复此过程直到所有边都被检测完为止。检测当前边是否为候选边，即判断该边的并入是否会构成回路，如不构成回路，则将该边并入生成树中。 克鲁斯卡尔算法的时间复杂度主要由选取的排序算法sort()决定。排序算法处理数据的规模由图的边数E决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图。 最短路径迪杰斯特拉算法手工求解 已并入顶点 | 剩余顶点 | dist[] | path[] 时间复杂度为O(n²)。 弗洛伊德算法手工求解 十字交叉法 A-1-A3 | Path-1-Path3 时间复杂度为O(n³)。 拓扑排序手工排序 时间复杂度为O(n+e)，其中n为顶点个数，e为边的条数。 最短路径 根据图求出拓扑有序序列a和逆拓扑有序序列b。 根据a和b分别求出每个事件（顶点）的最早发生时间ve()和最迟发生时间vl()。 根据2中结果求出每个活动（边）的最早发生时间e()和最迟发生时间l()。 根据3中结果找出最早发生时间和最迟发生时间相同的活动，即为关键活动。由关键活动所连成的路径即为关键路径。 活动 | 最早发生时间 | 最迟发生时间 | 关键活动 排序 以下算法基于非递减排序。 插入类排序直接插入排序 时间复杂度：最坏O(n²)，最好O(n)，平均O(n²)。空间复杂度：O(1)。 折半插入排序采用折半查找法来确定插入位置，基本条件是序列已经有序。 时间复杂度：最坏O(n²)，最好O(nlog₂n)，平均O(n²)。空间复杂度：O(1)。 希尔排序手写每一趟排序的执行情况。 时间复杂度与增量选取有关，平均O(nlog₂n)。增量序列的值尽量没有除1以外的公因子，最后一定取1。空间复杂度为O(1)。不稳定。 交换类排序起泡排序 时间复杂度：最坏O(n²)，最好O(n)，平均O(n²)。空间复杂度：O(1)。 快速排序 时间复杂度：最坏O(n²)，最好O(nlog₂n)，平均O(nlog₂n)。空间复杂度：O(log₂n)。不稳定。 选择类排序简单选择排序 时间复杂度：O(n²)，与初始序列无关。空间复杂度：O(1)。 堆排序手工建堆、排序。 从无序序列所确定的完全二叉树的最后一个非叶节点开始，从右往左，从下往上，对每个结点进行调整，得到一个大顶堆。（向下调整） 将当前无序序列中的第一个关键字a（根结点）与最后一个关键字b（最后一个叶子结点）交换。无序序列关键字减少1个，有序序列关键字增加1个。此时只有b可能不满足堆的定义，对其进行调整。 重复第2步，直到无序序列的关键字只剩1个。 插入结点：放在最底层的最右边，然后向上调整。 删除结点：把最底层最右边的叶子的值赋给删除位置，然后向下调整。 时间复杂度：O(nlog₂n)，即使在最坏情况下。这是相对于快速排序最大的优点。 空间复杂度：O(1)，在所有时间复杂度为O(nlog₂n)的排序中是最小的。 二路归并排序 时间复杂度：O(nlog₂n)，与初始序列无关 。空间复杂度：O(n)。 基数排序手工分配收集。 时间复杂度：O(d(n+rd)) 空间复杂度：O(rd) n为序列中的关键字数；d为关键字的位数（如930由3位组成，d&#x3D;3）；rd为关键字基的个数，如关键字为十进制数值时，rd&#x3D;10。 基数排序适合关键字很多，但关键字基较小的序列。如数字0~9是可以接受的，但如果是26个字母而且大多数关键字的最高位不相同，可以考虑“最高位优先”法。 查找顺序查找法 时间复杂度：O(n)。 折半查找法迭代版： 递归版： 时间复杂度：O(log₂n)。 建立折半查找判定树，求平均查找长度。 二叉排序树（二叉查找树）存储结构采用二叉链表进行存储，结点类型定义与一半的二叉树类似。 基本算法查找关键字 与折半查找法相似 插入关键字 首先要找到插入位置。对于一个不存在于二叉排序树中的关键字，查找不成功的位置即为插入位置。 构造二叉排序树 删除关键字 手工操作。 删除p结点： p结点为叶子结点。直接删除即可。 p结点只有左子树，或者只有右子树。将p删掉，并将p的子树直接连接在p与其双亲相连的指针上。 p结点既有左子树又有右子树。沿着p的左子树根结点的右指针一直往右走，直到来到其右子树的最右边一个结点r，然后将p中的关键字用r中的关键字代替。最后判断，如果r是叶子结点，就按照1的方法删除；如果r是非叶子节点，就用2的方法删除。 平衡二叉树（AVL树）平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。 平衡调整 调整失去平衡的最小子树。（任一子树不平衡就需调整） LL调整（右单旋转调整） RR调整（左单旋转调整） LR调整（先左后右双旋转调整） RL调整（先右后左双旋转调整） 删除结点操作与二叉排序树一致。 设Nh表示高度为h的平衡二叉树的最少结点数，则有 N0&#x3D;0, N1&#x3D;1, N2&#x3D;2, …, Nh&#x3D;Nh-1+Nh-2+1 B-树（B树）基本概念。 查找、插入、删除操作。 B+树基本概念。 散列表（Hash表）构造方法 直接定位法 数字分析法 平方取中法 除留余数法：p选择小于等于表长的最大素数 冲突处理方法 开放定址法 以发生冲突的Hash地址为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。 线性探查法：d+1 d+2 ... d+m-1 容易产生堆积问题。 平方探查法：d+1² d-1² d+2² d-2² ... 可以减少堆积问题的出现，不能探查到Hash表上的所有单元，但至少能探测到一半单元。 链地址法 把所有同义词用单链表连接起来。 性能分析查找成功时的平均查找长度是指找到表中已有表项的平均比较次数（分母是关键字个数）； 查找不成功时的平均查找长度是指在表中找不到待查的表项，但找到插入位置的平均比较次数（分母是表长度）。 装填因子是关键字个数与表长度的比值。"},{"title":"Hello World","date":"2023-01-07T01:52:00.000Z","url":"/2023/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]
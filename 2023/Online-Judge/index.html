<!DOCTYPE html>

<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>机试笔记 | Idealisti</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/atom-one-light.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/atom-one-light.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="Idealisti"><meta name="msapplication-starturl" content="https://idealisti.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Idealisti"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="机试笔记 | Idealisti"><meta property="og:site_name" content="Idealisti"><meta property="og:type" content="article"><meta property="og:url" content="https://idealisti.github.io/2023/Online-Judge/"><meta property="og:locale" content="zh-CN"><meta name="description" content="我习惯的格式化风格： 12&amp;quot;C_Cpp.clang_format_style&amp;quot;:&amp;quot;&amp;#123; BasedOnStyle: Chromium, IndentWidth: 4, ColumnLimit: 0 &amp;#125;&amp;quot; - Li Yijie - Idealisti"><meta name="keywords" content="算法"><meta property="article:published_time" content="2023-03-25T15:20:20.000Z"><meta property="article:modified_time" content="2023-04-05T15:26:31.944Z"><meta property="og:updated_time" content="2023-04-05T15:26:31.944Z"><meta property="article:author" content="Li Yijie"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="https://idealisti.github.io/2023/Online-Judge/">

    <meta name="generator" content="Hexo 6.3.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://idealisti.github.io/2023/Online-Judge/",
    "@type": "BlogPosting",
    "logo": "https://idealisti.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://idealisti.github.io/2023/Online-Judge/"
    },
    "headline": "机试笔记 | Idealisti",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://idealisti.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2023-03-25T15:20:20.000Z",
    "dateModified": "2023-04-05T15:26:31.944Z",
    "author": {
        "@type": "Person",
        "name": "Li Yijie",
        "image": {
            "@type": "ImageObject",
            "url": "https://idealisti.github.io/img/default_avatar.png"
        },
        "description": "Dream big. Start small."
    },
    "publisher": {
        "@type": "Organization",
        "name": "Idealisti",
        "logo": {
            "@type": "ImageObject",
            "url": "https://idealisti.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://idealisti.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "算法",
    "description": "我习惯的格式化风格： 12&amp;amp;quot;C_Cpp.clang_format_style&amp;amp;quot;:&amp;amp;quot;&amp;amp;#123; BasedOnStyle: Chromium, IndentWidth: 4, ColumnLimit: 0 &amp;amp;#125;&amp;amp;quot; - Li Yijie - Idealisti"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">Idealisti</a></h1>

    <p class="text-center header-slogan">
        
            
                Dream big. Start small.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">首页</a>
    
    
        <a href="/archives/" class="navbar-link">归档</a>
    
    
        <a href="/search" class="navbar-link">搜索</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">分享</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=Idealisti&url=https://idealisti.github.io&pic=https://idealisti.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=Idealisti&url=https://idealisti.github.io&via=Li Yijie" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://idealisti.github.io" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=https://idealisti.github.io" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://idealisti.github.io&title=机试笔记" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=Idealisti&title=机试笔记&summary=&pics=https://idealisti.github.io/img/suka-favicon.ico&url=https://idealisti.github.io" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=https://idealisti.github.io&text=机试笔记" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAAAAABQV18IAAAB10lEQVR42u3bu47EMAxD0fz/T++2g4VNUjspYuammSIPnwEEO5Kc6+eBxwUKFChQC9Qljs9rVterZ6j7tuOAqkEtg27wwL/PWJ2LxgFVhdoN5IJzhdhdo8YB9U7UCrIbXAU8KFCrQVb3ugkY1LtQuwfuBnSBrIBfvyWAejwqeYG74/e2bAbUo1G26GAW3DRhvbXqAurRKBWISQFDLdLp80F1otziu1uAXVKanAPVidoFsAzMYOF2CQSoPtRukCRwvwn4+CUP1JGotHD/n4lVvfyB6kS5CxUgKfRPJlBQHSh1wxStJtKoeQmqAqUmRxWwyYaISZMSVB9q2jia4GWy4LpYoI5DueTBBfcuwNMkBFQnKlmQ46ZPOKnKyRNUBUo1o93EmRTXkmIcqE6UK4a5opmaRF1zElQHatIkksWJsEgrCx+galCuIZkUVtMNzXIjBqhqVJJEJJtx1II8DnRQx6GmBdjJOVdMA9WDckda7HDJqfvToHpQadHCfYiRFGFtYgKqBqUCPG0WJQUM1TwA1YeafnAx2YCTFNZAvQuVbIJImgM24QD1OlSyAKdN7fHXIKCOQ7liabJwp83J0a4gUEeiJhua02bldPMNqB7Ukw5QoECB+jh+AdgHD770JqphAAAAAElFTkSuQmCC" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">机试笔记</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="Li Yijie's Avatar">
        <span>2023-03-25</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">分享本文</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=机试笔记&url=https://idealisti.github.io/2023/Online-Judge/&pic=https://idealisti.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=机试笔记&url=https://idealisti.github.io/2023/Online-Judge/&via=Li Yijie" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=https://idealisti.github.io/2023/Online-Judge/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=https://idealisti.github.io/2023/Online-Judge/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://idealisti.github.io/2023/Online-Judge/&title=Idealisti" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=Idealisti&title=Idealisti&summary=&pics=https://idealisti.github.io/img/suka-favicon.ico&url=https://idealisti.github.io/2023/Online-Judge/" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=https://idealisti.github.io/2023/Online-Judge/&text=Idealisti" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAAAAABQV18IAAAB10lEQVR42u3bu47EMAxD0fz/T++2g4VNUjspYuammSIPnwEEO5Kc6+eBxwUKFChQC9Qljs9rVterZ6j7tuOAqkEtg27wwL/PWJ2LxgFVhdoN5IJzhdhdo8YB9U7UCrIbXAU8KFCrQVb3ugkY1LtQuwfuBnSBrIBfvyWAejwqeYG74/e2bAbUo1G26GAW3DRhvbXqAurRKBWISQFDLdLp80F1otziu1uAXVKanAPVidoFsAzMYOF2CQSoPtRukCRwvwn4+CUP1JGotHD/n4lVvfyB6kS5CxUgKfRPJlBQHSh1wxStJtKoeQmqAqUmRxWwyYaISZMSVB9q2jia4GWy4LpYoI5DueTBBfcuwNMkBFQnKlmQ46ZPOKnKyRNUBUo1o93EmRTXkmIcqE6UK4a5opmaRF1zElQHatIkksWJsEgrCx+galCuIZkUVtMNzXIjBqhqVJJEJJtx1II8DnRQx6GmBdjJOVdMA9WDckda7HDJqfvToHpQadHCfYiRFGFtYgKqBqUCPG0WJQUM1TwA1YeafnAx2YCTFNZAvQuVbIJImgM24QD1OlSyAKdN7fHXIKCOQ7liabJwp83J0a4gUEeiJhua02bldPMNqB7Ukw5QoECB+jh+AdgHD770JqphAAAAAElFTkSuQmCC" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="post-toc-number">1.</span> <span class="post-toc-text">语言基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">字符数组的输入输出</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#string-h-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">string.h 头文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sscanf-%E4%B8%8E-sprintf"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">sscanf 与 sprintf</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">结构体的定义与访问</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">结构体的初始化</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F"><span class="post-toc-number">2.</span> <span class="post-toc-text">入门模拟</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">日期处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">进制转换</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5"><span class="post-toc-number">3.</span> <span class="post-toc-text">算法初步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">快速排序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sort-%E5%87%BD%E6%95%B0"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">sort() 函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">贪心</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E8%B4%AA%E5%BF%83"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">简单贪心</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">区间贪心</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%88%86"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">二分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">二分查找</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">函数估计</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="post-toc-number">4.</span> <span class="post-toc-text">数学问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">最大公约数与最小公倍数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%86%E6%95%B0"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">分数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%8C%96%E7%AE%80"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">分数的表示与化简</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E6%95%B0%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">分数的四则运算</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E6%95%B0%E7%9A%84%E8%BE%93%E5%87%BA"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">分数的输出</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B4%A0%E6%95%B0"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">素数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">大整数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%A7%E6%95%B4%E6%95%B0%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">定义大整数结构体</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5%E5%A4%A7%E6%95%B4%E6%95%B0"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">输入大整数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%AF%94%E8%BE%83%E4%B8%A4%E6%95%B0%E5%A4%A7%E5%B0%8F"><span class="post-toc-number">4.4.3.</span> <span class="post-toc-text">比较两数大小</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97"><span class="post-toc-number">4.4.4.</span> <span class="post-toc-text">大整数运算</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#STL"><span class="post-toc-number">5.</span> <span class="post-toc-text">STL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">vector</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#set"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">set</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#string"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">string</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#map"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">map</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stack"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">stack</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#queue"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">queue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#algorithm-%E4%B8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">algorithm 下的常用函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="post-toc-number">6.</span> <span class="post-toc-text">栈与队列</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A0%91"><span class="post-toc-number">7.</span> <span class="post-toc-text">树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">二叉树的存储结构与基本操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">二叉树的遍历</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="post-toc-number">8.</span> <span class="post-toc-text">搜索</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#DFS"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">DFS</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BFS"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">BFS</span></a></li></ol></li></ol></div>
                        
                    
                    <article id="post-content">
                        <p>我习惯的格式化风格：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;C_Cpp.clang_format_style&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="string">&quot;&#123; BasedOnStyle: Chromium, IndentWidth: 4, ColumnLimit: 0 &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="字符数组的输入输出"><a href="#字符数组的输入输出" class="headerlink" title="字符数组的输入输出"></a>字符数组的输入输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// scanf输入 printf输出</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// puts输出</span></span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一整行字符串（包含空格等空白符，scanf会作为结束标志)</span></span><br><span class="line"><span class="comment">// fgets</span></span><br><span class="line"><span class="built_in">fgets</span>(str, <span class="built_in">sizeof</span>(str), stdin);  <span class="comment">// 会读入换行符，puts输出会换行，strlen会多1个</span></span><br><span class="line"><span class="comment">// cin.getline</span></span><br><span class="line">cin.<span class="built_in">getline</span>(str, <span class="built_in">sizeof</span>(str));</span><br></pre></td></tr></table></figure>

<h4 id="string-h-头文件"><a href="#string-h-头文件" class="headerlink" title="string.h 头文件"></a>string.h 头文件</h4><ol>
<li><p><code>strlen(s)</code>: 得到字符数组长度（不包含最后的<code>\0</code>）。</p>
</li>
<li><p><code>strcmp(s1, s2)</code>: 以字典序比较数组大小。$s1 &lt; s2$ 返回负数，$s1 &gt; s2$ 返回正数，相等返回 $0$。</p>
</li>
<li><p><code>strcpy(s1, s2)</code>: 把 $s2$ 复制给 $s1$，包括结束符<code>\0</code>。</p>
</li>
<li><p><code>strcat(s1, s2)</code>: 把 $s2$ 接到 $s1$ 后面。</p>
</li>
</ol>
<h4 id="sscanf-与-sprintf"><a href="#sscanf-与-sprintf" class="headerlink" title="sscanf 与 sprintf"></a>sscanf 与 sprintf</h4><p>sscanf 将字符数组的内容按一定格式写到变量或其他字符数组中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> db;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;2048:3.14,hello&quot;</span>, str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">&quot;%d:%lf,%s&quot;</span>, &amp;n, &amp;db, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n = %d, db = %.2f, str2 = %s&quot;</span>, n, db, str2);</span><br></pre></td></tr></table></figure>

<p>输出：<code>n = 2048, db = 3.14, str2 = hello</code>。</p>
<p>sprintf 将变量或字符数组以一定格式写到一个字符数组中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">12</span>;</span><br><span class="line"><span class="type">double</span> db = <span class="number">3.1416</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>], str2[<span class="number">100</span>] = <span class="string">&quot;good&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%d:%.2f,%s&quot;</span>, n, db, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str = %s&quot;</span>, str);</span><br></pre></td></tr></table></figure>

<p>输出：<code>str = 12:3.14, good</code>。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="结构体的定义与访问"><a href="#结构体的定义与访问" class="headerlink" title="结构体的定义与访问"></a>结构体的定义与访问</h4><p>定义一个<code>student</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    student* next;  <span class="comment">// 不能定义自身，但可以定义自身类型的指针</span></span><br><span class="line">&#125; stu, *p;</span><br></pre></td></tr></table></figure>

<p>访问 $stu$ 中元素：<code>stu.id</code> <code>stu.name</code> <code>stu.next</code>。</p>
<p>访问 $p$ 中元素：<code>p-&gt;id</code> <code>p-&gt;name</code> <code>p-&gt;next</code>。</p>
<h4 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">idol</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> gender;  <span class="comment">// M F</span></span><br><span class="line">    <span class="comment">// 无参数传递的初始化构造函数，用于直接定义idol对象mj</span></span><br><span class="line">    <span class="built_in">idol</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 用以对结构体内部变量赋值</span></span><br><span class="line">    <span class="built_in">idol</span>(string _name, <span class="type">int</span> _id, <span class="type">char</span> _gender) &#123;</span><br><span class="line">        name += _name;  <span class="comment">// 以插入的方式</span></span><br><span class="line">        id = _id;</span><br><span class="line">        gender = _gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; mj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    idol michael = <span class="built_in">idol</span>(<span class="string">&quot;Michael Jackson&quot;</span>, <span class="number">19580829</span>, <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; michael.name &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; michael.id &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; michael.gender;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：<code>Michael Jackson 19580829 M</code>。</p>
<h2 id="入门模拟"><a href="#入门模拟" class="headerlink" title="入门模拟"></a>入门模拟</h2><h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><p>闰年判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> month[<span class="number">2</span>][<span class="number">13</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLeap</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日期差值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> time1, y1, m1, d1;  <span class="comment">// yyyymmdd</span></span><br><span class="line">    <span class="type">int</span> time2, y2, m2, d2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;time1, &amp;time2);</span><br><span class="line">    <span class="keyword">if</span> (time1 &gt; time2)  <span class="comment">// 第一个大于第二个则互换</span></span><br><span class="line">        <span class="built_in">swap</span>(time1, time2);</span><br><span class="line">    y1 = time1 / <span class="number">10000</span>, m1 = time1 % <span class="number">10000</span> / <span class="number">100</span>, d1 = time1 % <span class="number">100</span>;</span><br><span class="line">    y2 = time1 / <span class="number">10000</span>, m2 = time1 % <span class="number">10000</span> / <span class="number">100</span>, d2 = time1 % <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2) &#123;</span><br><span class="line">        d1++;                                   <span class="comment">// 天数加1</span></span><br><span class="line">        <span class="keyword">if</span> (d1 == month[<span class="built_in">isLeap</span>(y1)][m1] + <span class="number">1</span>) &#123;  <span class="comment">// 当月天数满</span></span><br><span class="line">            m1++;</span><br><span class="line">            d1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m1 == <span class="number">13</span>) &#123;  <span class="comment">// 月份满</span></span><br><span class="line">            y1++;</span><br><span class="line">            m1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>反序数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*输出n的反序ams*/</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;    <span class="comment">//将n逐位分解</span></span><br><span class="line">    ans *= <span class="number">10</span>;</span><br><span class="line">    ans += n % <span class="number">10</span>;</span><br><span class="line">    n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换为十进制数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二进制bin转十进制dec */</span></span><br><span class="line"><span class="type">int</span> bin;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bin);</span><br><span class="line"><span class="type">int</span> dec = <span class="number">0</span>, product = <span class="number">1</span>;  <span class="comment">// product不断乘2，得1, 2, 2^2...</span></span><br><span class="line"><span class="keyword">while</span> (bin != <span class="number">0</span>) &#123;</span><br><span class="line">    dec += (bin % <span class="number">10</span>) * product;  <span class="comment">// bin%10 得到个位数</span></span><br><span class="line">    bin /= <span class="number">10</span>;</span><br><span class="line">    product *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 十六进制hex转十进制dec（通用）*/</span></span><br><span class="line">string hex;</span><br><span class="line">cin &gt;&gt; hex;                          <span class="comment">// 需要用字符串或字符数组</span></span><br><span class="line"><span class="type">int</span> dec = <span class="number">0</span>, position;               <span class="comment">// position取得当前位的十进制表示</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hex.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hex[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; hex[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        position = hex[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        position = hex[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    dec = dec * <span class="number">16</span> + position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从十进制数转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*十进制dec转二进制bin*/</span></span><br><span class="line"><span class="type">int</span> bin[MAXN], num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    bin[num++] = dec % <span class="number">2</span>;</span><br><span class="line">    dec /= <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (dec != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bin[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*十进制dec转为十六进制hex*/</span></span><br><span class="line"><span class="type">int</span> hex[MAXN], num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    hex[num++] = dec % <span class="number">16</span>;</span><br><span class="line">    dec /= <span class="number">16</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (dec != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hex[i] &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, hex[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, hex[i] - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>);  <span class="comment">// cout输出用强制转换(char)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法初步"><a href="#算法初步" class="headerlink" title="算法初步"></a>算法初步</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp, i = low, j = high;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        temp = R[low];  <span class="comment">// 通常取第一个作为枢纽</span></span><br><span class="line">        <span class="comment">/*以下循环完成一趟排序*/</span></span><br><span class="line">        <span class="comment">/*小于temp的关键字放在左边，大于temp的关键字放在右边*/</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; R[j] &gt;= temp)  <span class="comment">// 从右往左扫描</span></span><br><span class="line">                j--;                       <span class="comment">// 找到一个小于temp的关键字</span></span><br><span class="line">            R[i] = R[j];                   <span class="comment">// 放在temp最终位置的左边</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i] &lt; temp)   <span class="comment">// 从左往右扫描</span></span><br><span class="line">                i++;                       <span class="comment">// 找到一个大于等于temp的关键字</span></span><br><span class="line">            R[j] = R[i];                   <span class="comment">// 放在temp最终位置的右边</span></span><br><span class="line">        &#125;</span><br><span class="line">        R[i] = temp;                <span class="comment">// 将temp放在最终位置</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(R, low, i - <span class="number">1</span>);   <span class="comment">// 递归地对temp左边的关键字进行排序</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(R, i + <span class="number">1</span>, high);  <span class="comment">// 递归地对temp右边的关键字进行排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求第 $k$ 小的数（令最小为第 $0$ 小），将快速排序稍作修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">findK</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp, i = low, j = high;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        temp = R[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; R[j] &gt;= temp)</span><br><span class="line">                j--;</span><br><span class="line">            R[i] = R[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; R[i] &lt; temp)</span><br><span class="line">                i++;</span><br><span class="line">            R[j] = R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        R[i] = temp;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; i)</span><br><span class="line">            <span class="built_in">findK</span>(R, low, i - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; i)</span><br><span class="line">            <span class="built_in">findK</span>(R, i + <span class="number">1</span>, high, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>R[k]</code>即为所求。由于每次处理的区间长度都会减半，所以是线性复杂度。</p>
<h4 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort() 函数"></a>sort() 函数</h4><p><code>#include &lt;algorithm&gt;</code></p>
<p>使用方式：<code>sort(first, last, [cmp])</code></p>
<p>给<strong>地址</strong>为 $[first,last)$ 内的元素排序。如果不写比较函数<code>cmp</code>，默认进行递增排序。</p>
<p>比较函数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span> </span>&#123;           <span class="comment">// 要使a排在b前</span></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() != b.<span class="built_in">length</span>())        <span class="comment">// 若长度不同</span></span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>();  <span class="comment">// 长的在前</span></span><br><span class="line">    <span class="keyword">else</span>                                 <span class="comment">// 否则</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;                    <span class="comment">// 字典序大的在前（见STL部分）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h4 id="简单贪心"><a href="#简单贪心" class="headerlink" title="简单贪心"></a>简单贪心</h4><p>金币与背包问题：在背包中装入价值量最高的金币。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, t;  <span class="comment">// 金币种类数，包称重量</span></span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">sort</span>(以金币单价排序);</span><br><span class="line"><span class="keyword">for</span> (枚举金币种类n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (库存 &lt;= 剩余承重) &#123;</span><br><span class="line">        剩余承重 -= 该类金币重量;</span><br><span class="line">        ans += 该类金币总价值;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 库存 &gt; 剩余承重</span></span><br><span class="line">        ans += 该类金币单价 * 剩余承重;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &gt;&gt; ans;</span><br></pre></td></tr></table></figure>

<h4 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h4><p>区间不相交问题：给出数个开区间 $(x,y)$，从中尽可能选择多的区间，使它们两两不相交。<strong>总是先选择左端点最大的区间，相同时先选择右端点最小的区间</strong>（反之也可以）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Interval a, Interval b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.left != b.left)</span><br><span class="line">        <span class="keyword">return</span> a.left &gt; b.left;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a.right &lt; b.right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">sort</span>(以先左大再右小排序);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>, lastLeft = I[<span class="number">0</span>].left;  <span class="comment">// 记录上一个被选中区间的左端点</span></span><br><span class="line">    <span class="keyword">for</span> (枚举区间) &#123;</span><br><span class="line">        <span class="keyword">if</span> (I[i].right &lt;= lastLeft) &#123;  <span class="comment">// 该区间的右端点在lastLeft左边</span></span><br><span class="line">            lastLeft = I[i].left;      <span class="comment">// 作为新选中区间</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间选点问题：给出数个闭区间 $[x,y]$，最少需要确定几个点，才能使每个闭区间都存在至少一个点。本质上就是求两两不相交的区间数，只需把以上代码中的<code>I[i].right &lt;= lastLeft</code>改成<code>I[i].right &lt; lastLeft</code>即可。</p>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>递归版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bsearch</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到，返回-1</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (R[mid] == k)</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到，返回下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (R[mid] &gt; k)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Bsearch</span>(R, low, mid - <span class="number">1</span>, k);  <span class="comment">// 在左段中查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Bsearch</span>(R, mid + <span class="number">1</span>, high, k);  <span class="comment">// 在右段中查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Bsearch</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;        <span class="comment">// 子表长度大于等于1时循环</span></span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 取当前表的中间位置</span></span><br><span class="line">        <span class="keyword">if</span> (R[mid] == k)</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 找到后返回元素的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (R[mid] &gt; k)</span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">// 继续在R[low, ..., mid-1]中查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 继续在R[mid+1, ..., high]中查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>固定模板：寻找有序序列中<strong>第一个满足某条件的元素</strong>的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 闭区间 [low, high] */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;  <span class="comment">// 如果相等代表找到了</span></span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (条件成立) &#123;  <span class="comment">// 条件成立，第一个满足条件的元素位置&lt;=mid</span></span><br><span class="line">            high = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 条件不成立，第一个满足条件的元素位置&gt;mid</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回夹出来的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果要求<strong>最后一个满足条件</strong>的元素的位置，可以先求第一个满足<code>!条件</code>的元素位置，然后减1即可。</p>
</blockquote>
<blockquote>
<p>可以用<code>lower_bound()</code>和<code>upper_bound()</code>实现。</p>
</blockquote>
<h4 id="函数估计"><a href="#函数估计" class="headerlink" title="函数估计"></a>函数估计</h4><p>二分法估计函数参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 浮点数 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-5</span>;  <span class="comment">// 精度为10^-5</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;         <span class="comment">// 计算f(x)以估计x</span></span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> L, <span class="type">double</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> low = L, high = R, mid;</span><br><span class="line">    <span class="keyword">while</span> (high - low &gt; eps) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 取中点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(low) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            high = mid;  <span class="comment">// 往子区间 [low, mid] 继续逼近</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid;  <span class="comment">// 往子区间 [mid, high] 继续逼近</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid;  <span class="comment">// 返回mid值 即f(x)=0的根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数，为了避免无限循环，需要这么写 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = L, high = R, mid, ans;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;    <span class="comment">// 小于等于</span></span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(mid) &gt;= m) &#123;</span><br><span class="line">            ans = mid;       <span class="comment">// 满足条件，先记录ans</span></span><br><span class="line">            low = mid + <span class="number">1</span>;   <span class="comment">// 不用考虑加1减1，全部写上去</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h2><h3 id="最大公约数与最小公倍数"><a href="#最大公约数与最小公倍数" class="headerlink" title="最大公约数与最小公倍数"></a>最大公约数与最小公倍数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最大公约数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最小公倍数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><h4 id="分数的表示与化简"><a href="#分数的表示与化简" class="headerlink" title="分数的表示与化简"></a>分数的表示与化简</h4><p>最简洁的写法是写成<strong>假分数</strong>的形式，分子分母都保留原数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fraction</span> &#123;</span><br><span class="line">    <span class="type">int</span> up, down;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分数的化简分为三步：</p>
<ol>
<li><p>如果分母 $down$ 为负数，则令分子 $up$ 与分母 $down$ 都变为相反数。</p>
</li>
<li><p>如果分子 $up$ 为 $0$，则令分母 $down$ 为 $1$。</p>
</li>
<li><p>约分：求分子<strong>绝对值</strong>与分母<strong>绝对值</strong>的最大公约数，然后令分子分母同时除以该数。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">reduct</span><span class="params">(Fraction result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.down &lt; <span class="number">0</span>) &#123;  <span class="comment">// 分母为负数，分子分母都取反</span></span><br><span class="line">        result.up *= <span class="number">-1</span>;</span><br><span class="line">        result.down *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.up == <span class="number">0</span>) &#123;                               <span class="comment">// 如果分子为0</span></span><br><span class="line">        result.down = <span class="number">1</span>;                                <span class="comment">// 分母取1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// 否则进行约分</span></span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(result.up), <span class="built_in">abs</span>(result.down));  <span class="comment">// 最大公约数</span></span><br><span class="line">        result.up /= d;                                 <span class="comment">// 约去最大公约数</span></span><br><span class="line">        result.down /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分数的四则运算"><a href="#分数的四则运算" class="headerlink" title="分数的四则运算"></a>分数的四则运算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 加法 */</span></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.down + f2.up * f1.down;</span><br><span class="line">    result.down = f1.down * f2.down;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduct</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 减法 */</span></span><br><span class="line"><span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.down - f2.up * f1.down;</span><br><span class="line">    result.down = f1.down * f2.down;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduct</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 乘法 */</span></span><br><span class="line"><span class="function">Fraction <span class="title">multi</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.up;</span><br><span class="line">    result.down = f1.down * f2.down;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduct</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 除法 */</span></span><br><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction f1, Fraction f2)</span> </span>&#123;  <span class="comment">// 需判断f2.up不为0</span></span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up * f2.down;</span><br><span class="line">    result.down = f1.down * f2.up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reduct</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分数的输出"><a href="#分数的输出" class="headerlink" title="分数的输出"></a>分数的输出</h4><ol>
<li><p>输出分数前，先进行化简。</p>
</li>
<li><p>如果分母 $down$ 为 $1$，说明是整数，则直接输出分子。</p>
</li>
<li><p>如果分子 $up$ 的<strong>绝对值</strong>大于分母 $down$，说明是假分数，则按带分数的形式输出。</p>
</li>
<li><p>真分数直接输出即可。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">showResult</span><span class="params">(Fraction r)</span> </span>&#123;</span><br><span class="line">    r = <span class="built_in">reduct</span>(r);</span><br><span class="line">    <span class="keyword">if</span> (r.down == <span class="number">1</span>) &#123;  <span class="comment">// 整数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, r.up);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(r.up) &gt; r.down) &#123;  <span class="comment">// 假分数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d/%d&quot;</span>, r.up / r.down, <span class="built_in">abs</span>(r.up) % r.down, r.down);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 真分数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>, r.up, r.down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分数的乘除法可以使分子或分母超出<code>int</code>表示范围，一般情况下，使用<code>long long</code>存储。</p>
</blockquote>
<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><p>素数判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 $n$ 接近上界，会导致 $i*i$ 溢出，则采用开根号的写法<code>i &lt;= (int)sqrt(n)</code>。</p>
</blockquote>
<p>素数表获取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prime[MAXN], pNum = <span class="number">0</span>;  <span class="comment">// prime存放素数，pNum为素数个数</span></span><br><span class="line"><span class="type">bool</span> p[MAXN] = &#123;<span class="literal">false</span>&#125;;     <span class="comment">// 如果i为素数，p[i]为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPrime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[i]) &#123;            <span class="comment">// 如果i是素数</span></span><br><span class="line">            prime[pNum++] = i;  <span class="comment">// 把素数i存到prime数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt; MAXN; j += i)</span><br><span class="line">                p[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h3><p>整数的高位存储在数组的高位，整数的低位存储在数组的低位。因此读入之后需要在另存为<code>d[]</code>数组的时候反转。</p>
<h4 id="定义大整数结构体"><a href="#定义大整数结构体" class="headerlink" title="定义大整数结构体"></a>定义大整数结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span> &#123;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">bign</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="输入大整数"><a href="#输入大整数" class="headerlink" title="输入大整数"></a>输入大整数</h4><p>读入字符串，另存为<code>bign</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="type">char</span> str[])</span> </span>&#123;</span><br><span class="line">    bign a;</span><br><span class="line">    a.len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">        a.d[i] = str[a.len - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 逆向赋值</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="比较两数大小"><a href="#比较两数大小" class="headerlink" title="比较两数大小"></a>比较两数大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(bign a, bign b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.len &gt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// a大</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.len &lt; b.len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// b大</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.d[i] &gt; b.d[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.d[i] &lt; b.d[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 两数相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大整数运算"><a href="#大整数运算" class="headerlink" title="大整数运算"></a>大整数运算</h4><p>加法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span> </span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;                                  <span class="comment">// carry是进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++) &#123;  <span class="comment">// 以较长的为界限</span></span><br><span class="line">        <span class="type">int</span> temp = a.d[i] + b.d[i] + carry;         <span class="comment">// 两个对应位与进位相加</span></span><br><span class="line">        c.d[c.len++] = temp % <span class="number">10</span>;                   <span class="comment">// 个位数为该位结果</span></span><br><span class="line">        carry = temp / <span class="number">10</span>;                          <span class="comment">// 十位数为新的进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>)            <span class="comment">// 如果最后进位不为0</span></span><br><span class="line">        c.d[c.len++] = carry;  <span class="comment">// 则直接赋给结果的最高位</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a, bign b)</span> </span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len || i &lt; b.len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.d[i] &lt; b.d[i]) &#123;  <span class="comment">// 如果不够减</span></span><br><span class="line">            a.d[i + <span class="number">1</span>]--;       <span class="comment">// 向高位借位</span></span><br><span class="line">            a.d[i] += <span class="number">10</span>;       <span class="comment">// 当前位加10</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.d[c.len++] = a.d[i] - b.d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt;= <span class="number">2</span> &amp;&amp; c.d[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;  <span class="comment">// 去除高位的0，同时保留一位最低位</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乘法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 低精度 */</span></span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a.d[i] * b + carry;</span><br><span class="line">        c.d[c.len++] = temp % <span class="number">10</span>;</span><br><span class="line">        carry = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (carry != <span class="number">0</span>) &#123;  <span class="comment">// 不同于加法，进位可能不止一位，因此用while</span></span><br><span class="line">        c.d[c.len++] = carry % <span class="number">10</span>;</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高精度 */</span></span><br><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a, bign b)</span> </span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len + b.len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; j++)</span><br><span class="line">            c.d[i + j] += a.d[i] * b.d[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.d[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            c.d[i + <span class="number">1</span>] += c.d[i] / <span class="number">10</span>;</span><br><span class="line">            c.d[i] = c.d[i] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt;= <span class="number">2</span> &amp;&amp; c.d[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a, <span class="type">int</span> b, <span class="type">int</span>&amp; r)</span> </span>&#123;  <span class="comment">// r为余数，传入取0</span></span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len;                  <span class="comment">// 被除数和商的每一位是对应的，先令长度相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 从高位开始</span></span><br><span class="line">        r = r * <span class="number">10</span> + a.d[i];                <span class="comment">// 与上一位的余数组合</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; b)</span><br><span class="line">            c.d[i] = <span class="number">0</span>;      <span class="comment">// 不够除</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// 够除</span></span><br><span class="line">            c.d[i] = r / b;  <span class="comment">// 商的该位</span></span><br><span class="line">            r %= b;          <span class="comment">// 获得新的余数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c.len &gt;= <span class="number">2</span> &amp;&amp; c.d[c.len - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        c.len--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>变长数组</p>
<p><code>#include &lt;vector&gt;</code></p>
<p>元素访问：</p>
<ol>
<li><p>通过下标访问（<code>vi[index]</code>）。</p>
</li>
<li><p>通过迭代器访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">typename</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>(); it++ &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以用 auto 代替初始化类型：auto it = vi.begin()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用STL容器中，只有<code>vector</code>和<code>string</code>支持<code>vi.begin()+3</code>这种迭代器加上整数的写法。</p>
</blockquote>
</li>
</ol>
<p>常用实例：</p>
<ol>
<li><p><code>vi.push_back(x)</code>: 在末尾追加元素 $x$。</p>
</li>
<li><p><code>vi.pop_back()</code>: 删除尾元素。</p>
</li>
<li><p><code>vi.size()</code>: 返回变长数组长度。</p>
</li>
<li><p><code>vi.clear()</code>: 清空所有元素。</p>
</li>
<li><p><code>vi.insert(it, x)</code>: 在迭代器<code>it</code>处插入元素 $x$。</p>
</li>
<li><p><code>vi.erase(it)</code>: 删除单个元素，it 为需要删除元素的迭代器；<code>vi.erase(first, last)</code>: 删除迭代器 $[first,last)$ 内的元素。</p>
</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>内部自动升序且不含重复元素的容器。</p>
<p><code>include &lt;set&gt;</code></p>
<p>常用实例：</p>
<ol>
<li><p><code>st.insert(x)</code>: 插入元素 $x$。</p>
</li>
<li><p><code>st.find(value)</code>: 返回对应数值为 $value$ 的迭代器，找不到时返回<code>st.end()</code>。</p>
</li>
<li><p><code>st.erase(it)</code>: <code>it</code>为所需要删除元素的迭代器；<code>st.erase(value)</code>: $value$ 为所需要删除元素的值；<code>st.erase(first, last)</code>: 删除迭代器 $[first,last)$ 内的元素。</p>
</li>
<li><p><code>st.size()</code>: 获得元素个数。</p>
</li>
<li><p><code>st.clear()</code>: 清空所有元素。</p>
</li>
</ol>
<blockquote>
<p>如果要逆序（降序）输出：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::reverse_iterator it = st.<span class="built_in">rbegin</span>(); it != st.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>set</code>中是数据是唯一的。如果要处理不唯一的情况，用<code>multiset</code>。如果要只去重不排序，使用<code>unordered_set</code>。</p>
</blockquote>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>#include &lt;string&gt;</code></p>
<p>输入输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="comment">// 只能使用cin和cout</span></span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; str;</span><br><span class="line"><span class="comment">// 如果要读入整行</span></span><br><span class="line"><span class="built_in">getline</span>(cin, str);    <span class="comment">// 注意与字符数组cin.getline的区别</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cin</code>与<code>getline</code>混用需谨慎。<code>cin &gt;&gt;</code>不会读入最后的换行符<code>\n</code>，而<code>getline</code>是以<code>\n</code>为结束标记的。如果必须混用，在<code>cin &gt;&gt;</code>这句后面加一行<code>cin.ignore()</code>。</p>
</blockquote>
<p>常用实例：</p>
<ol>
<li><p><code>s += str</code>或<code>s.append(str)</code>: 在字符串 s 后拼接字符串 str。</p>
</li>
<li><p><code>s &lt; str</code>: 以字典序比较两个字符串。</p>
</li>
<li><p><code>s.length()</code>或<code>s.size()</code>: 字符串长度。</p>
</li>
<li><p><code>s.substr(pos, len)</code>: 范围从 pos 号位开始、长度为 len 的子串。</p>
</li>
<li><p><code>s.insert(pos, str)</code>: 在 pos 号位置插入字符串 str。</p>
</li>
<li><p><code>s.find(str, [pos])</code>: （从 pos 号位开始）匹配 str，返回其在 s 中第一次出现的位置；如果 str 不是子串，则返回<code>string::npos</code>（unsigned_int 类型的最大值，强制转换为 int 类型后为-1，比较时可以令为-1）。</p>
</li>
<li><p><code>s.erase(it)</code>: 删除单个元素，it 为需要删除元素的迭代器；<code>s.erase(first, last)</code>: 删除迭代器 $[first,last)$ 内的元素。</p>
</li>
<li><p><code>s.clear()</code>: 清空字符串。</p>
</li>
</ol>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>#include &lt;map&gt;</code></p>
<p>定义：需要确定键 $key$ 与值 $value$ 两种类型。</p>
<p><code>map&lt;typename1, typename2&gt; mp;</code></p>
<blockquote>
<p>如果以字符串为键，必须使用<code>string</code>而不能使用<code>char</code>数组。</p>
</blockquote>
<p>访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">&#x27;c&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">mp[<span class="string">&#x27;b&#x27;</span>] = <span class="number">20</span>;</span><br><span class="line">mp[<span class="string">&#x27;a&#x27;</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">for</span>(map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c:%d &quot;</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：<code>a:30 b:20 c:10</code>。</p>
<p><code>map</code>会以键从小到大的顺序自动排序。不要排序，使用<code>unordered_map</code>。</p>
</blockquote>
<p>常用实例：</p>
<ol>
<li><p><code>mp.find(key)</code>: 返回键为 $key$ 的迭代器，找不到时返回<code>mp.end()</code>。</p>
</li>
<li><p><code>mp.erase(it)</code>: <code>it</code>为所需要删除元素的迭代器；<code>mp.erase(key)</code>: $key$ 为所需要删除元素的键；<code>mp.erase(first, last)</code>: 删除迭代器 $[first,last)$ 内的元素。</p>
</li>
<li><p><code>mp.size()</code>: 返回映射的对数。</p>
</li>
<li><p><code>mp.clear()</code>: 清空所有元素。</p>
</li>
</ol>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p><code>#include &lt;stack&gt;</code></p>
<p>常用实例：</p>
<ol>
<li><p><code>st.push(x)</code>: 将 $x$ 入栈。</p>
</li>
<li><p><code>st.top()</code>: 获得栈顶元素。</p>
</li>
<li><p><code>st.pop()</code>: 弹出栈顶元素。</p>
</li>
<li><p><code>st.empty()</code>: 检测栈是否为空。</p>
</li>
<li><p><code>st.size()</code>: 返回栈内元素个数。</p>
</li>
<li><p>栈的清空：可以用一个循环反复弹出元素直至清空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上更常用的方法是重新定义一个栈来变相实现栈的清空，不需很多时间。</p>
</blockquote>
</li>
</ol>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p><code>#include &lt;queue&gt;</code></p>
<p>常用实例：</p>
<ol>
<li><p><code>q.push(x)</code>: 将 $x$ 入队。</p>
</li>
<li><p><code>q.front()</code>: 获得队首元素。</p>
</li>
<li><p><code>q.back()</code>: 获得队尾元素元素。</p>
</li>
<li><p><code>q.pop()</code>: 令队首元素出队。</p>
</li>
<li><p><code>q.empty()</code>: 检测队是否为空。</p>
</li>
<li><p><code>q.size()</code>: 返回队内元素个数。</p>
</li>
<li><p>队列的清空：与栈类似。</p>
</li>
</ol>
<h3 id="algorithm-下的常用函数"><a href="#algorithm-下的常用函数" class="headerlink" title="algorithm 下的常用函数"></a>algorithm 下的常用函数</h3><p><code>max(x, y)</code>与<code>min(x, y)</code>分别返回 $x$ 与 $y$ 中的最大值和最小值，参数必须是两个，可以是浮点数。如果要比较三个数，可以使用<code>max(x, max(y, z))</code>的写法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* max() 与 min() 的一个实例 */</span></span><br><span class="line"><span class="type">int</span> maxN = INT_MIN, minN = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    maxN = <span class="built_in">max</span>(a[i), maxN);</span><br><span class="line">    minN = <span class="built_in">min</span>(a[i], minN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>lower_bound(first, last, val)</code>寻找数组或容器的 $[first,last)$ 范围内<strong>第一个值大于等于 $val$</strong> 的元素的位置；<code>upper_bound(first, last, val)</code>寻找数组或容器的 $[first,last)$ 范围内<strong>第一个值大于 $val$</strong> 的元素的位置。如果是数组，返回指针；如果是容器，返回迭代器。如果想获得元素的下标，另返回值<strong>减去数组首地址</strong>即可。</p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>中缀表达式转后缀表达式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">    queue&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    m[<span class="string">&#x27;+&#x27;</span>] = m[<span class="string">&#x27;-&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    m[<span class="string">&#x27;*&#x27;</span>] = m[<span class="string">&#x27;/&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; m[s.<span class="built_in">top</span>()] &gt;= m[str[i]]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后缀表达式求值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    stack&lt;<span class="type">double</span>&gt; st;</span><br><span class="line">    <span class="type">double</span> temp, temp1, temp2;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            st.<span class="built_in">push</span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            temp2 = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            temp1 = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    temp = temp1 + temp2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    temp = temp1 - temp2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    temp = temp1 * temp2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    temp = temp1 / temp2;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, st.<span class="built_in">top</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树的存储结构与基本操作"><a href="#二叉树的存储结构与基本操作" class="headerlink" title="二叉树的存储结构与基本操作"></a>二叉树的存储结构与基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="keyword">typename</span> data;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// node* root = NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成一个新结点，v为结点数据 */</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;data = v;</span><br><span class="line">    Node-&gt;lchild = Node-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查找并修改二叉树结点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(node* root, <span class="type">int</span> x, <span class="type">int</span> newdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == x) &#123;</span><br><span class="line">        root-&gt;data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">search</span>(root-&gt;lchild, x, newdata);</span><br><span class="line">    <span class="built_in">search</span>(root-&gt;rchild, x, newdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入一个数据域为x的结点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node*&amp; root, <span class="type">int</span> x)</span> </span>&#123;  <span class="comment">// 根结点指针必须用引用</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root = <span class="built_in">newNode</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span>(root-&gt;lchild, x);  <span class="comment">// 递归往左子树搜索</span></span><br><span class="line">    <span class="built_in">insert</span>(root-&gt;rchild, x);  <span class="comment">// 递归往右子树搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据读入的数组创建二叉树 */</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;  <span class="comment">// 新建空根</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(root, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>先序遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, root-&gt;data); <span class="comment">//访问根节点</span></span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">preorder</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历</p>
<p>如果要求计算结点所处的层次，结点定义中增加一个<code>int layer</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">layerorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;node*&gt; q;  <span class="comment">// 注意是存地址，否则只修改副本</span></span><br><span class="line">    root-&gt;layer = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node* now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, now-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            now-&gt;lchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(now-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            now-&gt;rchild-&gt;layer = now-&gt;layer + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(now-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回某结点的层级</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意结构区别，先判断左子树是否能找到，找不到就去右子树找 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">level</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> x, <span class="type">int</span> L)</span> </span>&#123;    <span class="comment">// L为根结点层级，一般</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == x)</span><br><span class="line">            <span class="keyword">return</span> L;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">level</span>(node[root].lchild, x, L + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">level</span>(node[root].rchild, x, L + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层序遍历也可以做</span></span><br></pre></td></tr></table></figure>

<p>根据先序遍历序列和中序遍历序列重建二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前先序区间 [preL, preR]，中序区间 [inL, inR]，返回根节点地址 */</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> inL, <span class="type">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preL &lt; preR) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 先序序列长度为0时直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data = pre[preL];  <span class="comment">// 根节点的值为先序序列首位</span></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (k = inL; k &lt;= inR; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[k] == pre[preL])  <span class="comment">// 中序序列中找到根节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> leftNum = k - inL;  <span class="comment">// 左子树结点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在左子树中递归，返回左子树的根节点</span></span><br><span class="line">    root-&gt;lchild = <span class="built_in">create</span>(preL + <span class="number">1</span>, preL + leftNum, inL, k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在右子树中递归，返回右子树的根节点</span></span><br><span class="line">    root-&gt;rchild = <span class="built_in">create</span>(preL + leftNum + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>有 $n$ 件物品，每件物品重量 $w[i]$，价值 $c[i]$。取出若干件物品放入容量为 $V$ 的背包中，让背包内的物品总价值最大，求最大价值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n, V, maxV = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w[maxn], c[maxn];</span><br><span class="line"><span class="comment">/* index为当前处理的物品编号，sumW和sumC为当前总重量和当前总价值 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n) &#123;  <span class="comment">// 已经完成对n件物品的选择（死胡同）</span></span><br><span class="line">        <span class="keyword">if</span> (sumW &lt;= V &amp;&amp; sumC &gt;= maxV) &#123;</span><br><span class="line">            maxV = sumC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 岔路口</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW, sumC);                        <span class="comment">// 不选第index件物品</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);  <span class="comment">// 选第index件物品</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始时为第0件物品，当前总重量和总价值均为0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, maxV);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，总是把所有物品全部确定之后才去更新最大价值。可以把对 $sumW$ 的判断加入岔路口中，只有当 $sumW&lt;V$ 时才进入“选择当前物品”的岔道，即<strong>剪枝</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> sumW, <span class="type">int</span> sumC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == n) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW, sumC);  <span class="comment">// 不选第index件物品</span></span><br><span class="line">    <span class="comment">// 仅当加入第index件物品后未超重，才继续</span></span><br><span class="line">    <span class="keyword">if</span> (sumW + w[index] &lt;= V) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumC + c[index] &gt; maxV)</span><br><span class="line">            maxV = sumC;</span><br><span class="line">        <span class="built_in">DFS</span>(index + <span class="number">1</span>, sumW + w[index], sumC + c[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见的DFS解决方法：给定一个序列，枚举这个序列的所有自序列（可以不连续）。</p>
</blockquote>
<p>给定 $N$ 个整数（可能为负），从中选择 $K$ 个数，使得它们的和恰好等于给定的整数 $X$；如果有多个方案，从中选择元素平方和最大的方案。</p>
<p>首先确定一个数组 $temp$ 来存放当前已经选择的数。当试图选择<code>a[index]</code>时，就把它加进去；当这条分支结束时，再把它从 $temp$ 中去除，使它不影响“不选择<code>a[index]</code>”这条分支。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, k, x, maxSumSqu = <span class="number">-1</span>, a[maxn];</span><br><span class="line"><span class="comment">// temp保存临时方案，ans保存平方和最大方案</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; temp, ans;</span><br><span class="line"><span class="comment">// 当前处理index号整数，已选个数nowK，已选整数之和sum，已选整数平方和sumSqu</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> nowK, <span class="type">int</span> sum, <span class="type">int</span> sumSqu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowK == k &amp;&amp; sum == x) &#123;   <span class="comment">// 找到k个数的和为x</span></span><br><span class="line">        <span class="keyword">if</span> (sumSqu &gt; maxSumSqu) &#123;  <span class="comment">// 如果平方和更大</span></span><br><span class="line">            maxSumSqu = sumSqu;    <span class="comment">// 更新平方和</span></span><br><span class="line">            ans = temp;            <span class="comment">// 更新最优方案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经处理完n个数，或者超过k个数，或者和超过x，返回</span></span><br><span class="line">    <span class="keyword">if</span> (index == n || nowK &gt; k || sum &gt; x)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 选index号数</span></span><br><span class="line">    temp.<span class="built_in">push_back</span>(a[index]);</span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, nowK + <span class="number">1</span>, sum + a[index], sumSqu + a[index] * a[index]);</span><br><span class="line">    temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 不选index号数</span></span><br><span class="line">    <span class="built_in">DFS</span>(index + <span class="number">1</span>, nowK, sum, sumSqu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果允许重复选择，则当选择了<code>a[index]</code>时，不应该直接进入<code>a[index+1]</code>的处理，而是应当继续选择<code>a[index]</code>，直到不能再选择为止，再通过“不选 $index$ 号数”的分支进入 $index+1$ 号数的处理。只需把“选 $index$ 号数”的分支改成：<code>DFS(index, nowK + 1, sum + a[index], sumSqu + a[index]);</code>。</p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        取出队首元素top;</span><br><span class="line">        访问队首元素top;</span><br><span class="line">        将队首元素出队;</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<p>访问位置 $(x,y)$ 所在的块，将块中所有“$1$”的<code>inq</code>都设置为<code>true</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125; node;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q;  <span class="comment">// 定义队列</span></span><br><span class="line">    node.x = x;     <span class="comment">// 当前结点坐标为 (x,y)</span></span><br><span class="line">    node.y = y;</span><br><span class="line">    q.<span class="built_in">push</span>(node);      <span class="comment">// 结点入队</span></span><br><span class="line">    inq[x][y] = <span class="literal">true</span>;  <span class="comment">// 标记结点已入队</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node top = q.<span class="built_in">front</span>();  <span class="comment">// 取出队首</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;  <span class="comment">// 4个相邻位置</span></span><br><span class="line">            <span class="type">int</span> newX = top.x + dx[i];  <span class="comment">// 上下左右的偏移量</span></span><br><span class="line">            <span class="type">int</span> newY = top.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(newX, newY)) &#123;  <span class="comment">// 符合条件（未出界、未访问过等）</span></span><br><span class="line">                node.x = newX;</span><br><span class="line">                node.y = newY;</span><br><span class="line">                q.<span class="built_in">push</span>(node);</span><br><span class="line">                inq[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求起点 $S$ 到终点 $T$ 的最少步数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> inq[maxn][maxn] = &#123;<span class="literal">false</span>&#125;, maze[maxn][maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;  <span class="comment">// 坐标</span></span><br><span class="line">    <span class="type">int</span> step;  <span class="comment">// 步数</span></span><br><span class="line">&#125; s, t, node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (inq[x][y] || maze[x][y])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);  <span class="comment">// 起点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node top = q.<span class="built_in">front</span>();  <span class="comment">// 取出队首</span></span><br><span class="line">        q.<span class="built_in">pop</span>();               <span class="comment">// 队首出队</span></span><br><span class="line">        <span class="keyword">if</span> (top.x == t.x &amp;&amp; top.y == t.y) &#123;</span><br><span class="line">            <span class="keyword">return</span> top.step;  <span class="comment">// 到达终点，返回步数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;  <span class="comment">// 四个方向</span></span><br><span class="line">            <span class="type">int</span> newX = top.x + dx[i];</span><br><span class="line">            <span class="type">int</span> newY = top.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(newX, newY)) &#123;  <span class="comment">// 如果该相邻位置有效</span></span><br><span class="line">                <span class="comment">// 设置一个坐标为 (newX, newY) 的 Node node</span></span><br><span class="line">                node.x = newX, node.y = newY;</span><br><span class="line">                node.step = top.step + <span class="number">1</span>;  <span class="comment">// 步数为当前队首加1</span></span><br><span class="line">                q.<span class="built_in">push</span>(node);              <span class="comment">// 并将其入队</span></span><br><span class="line">                inq[newX][newY] = <span class="literal">true</span>;    <span class="comment">// 标记该位置入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 无法到达终点t时返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    s.x = s.y = s.step = <span class="number">0</span>;    <span class="comment">// 左上角为起点</span></span><br><span class="line">    t.x = n - <span class="number">1</span>, t.y = m - <span class="number">1</span>;  <span class="comment">// 右下角为终点</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">BFS</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    </article>
                    


    <blockquote id="date-expire-notification" class="post-expired-notify">本文最后更新于 <span id="date-expire-num"></span> 天前，文中所描述的信息可能已发生改变</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2023-04-05");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2023-03-25T15:20:20.000Z" itemprop="datePublished">2023-03-25</time>

    , 最后修改于&nbsp;<time datetime="2023-04-05T15:26:31.944Z" itemprop="dateModified">2023-04-05</time>

</p>
<p class="post-footer-info mb-0 pt-2">



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">#&nbsp;算法</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2023/Data-Structure/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">数据结构</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>


  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>
<script type="text/javascript" src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>




            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="https://idealisti.github.io">Idealisti</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>